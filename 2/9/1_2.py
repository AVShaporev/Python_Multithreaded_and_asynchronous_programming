# Дополним пример сверху демонстрацией поведения метода map с указанием тайм-аута:

import concurrent.futures
import time


def my_function(num):
    print(f"Start_processing_{num}")
    time.sleep(num)
    print(f"Finish_processing_{num}")
    return num * 2


with concurrent.futures.ThreadPoolExecutor(max_workers=1) as executor:
    results = executor.map(my_function, [1, 2, 3, 4, 3, 2, 1], timeout=11)
    while True:
        try:
            print(next(results))
        except concurrent.futures.TimeoutError:
            print("TimeoutError occurred")
        except StopIteration:
            print("StopIteration")
            break

'''
Здесь в цикле мы пытаемся получить результат вызова функции, ждем не более 11 секунд. Если запустить код, то можно увидеть, что на 4-м аргументе выполнение цикла завершается. Мы выходим по тайм-ауту. Также прекращается итерация. Новых вызовов функций с новыми на очереди аргументами не будет. Мы всего лишь дождемся завершения уже запущенных задач а затем получим завершение программы. Завершение по тайм-ауту на 4 аргументе происходит из-за того, что общее время ожидания от первого вызова my_function превысило 11 секунд (1+2+3+4+3 = 13 секунд). При этом, если добавить еще один поток, указав max_workers=2, то завершения по тайм-ауту уже не будет, т.к. время выполнение обработки каждым потоком будет равно не сумме всех ожиданий, а только половине от 16 секунд (1+2+3+4+3+2+1 = 16). Чтобы получить выход по тайм-ауту в случае двух потоков, мы должны указать значение менее 8 секунд.
'''

# Start_fsing_3